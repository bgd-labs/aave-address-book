import {Client, Hex, getAddress, getContract, zeroAddress} from 'viem';
import {IERC20Detailed_ABI} from '../../src/ts/abis/IERC20Detailed';
import {AddressInfo, Addresses} from '../configs/types';
import {getStorageAt} from 'viem/actions';
import {ChainList} from '@bgd-labs/toolbox';

function getExplorerLink(chainId: number, address: Hex) {
  const chain = ChainList[chainId];
  let url = chain.blockExplorers?.default.url;
  if (url && url.endsWith('/')) {
    url = url.slice(0, -1); // sanitize explorer url
  }
  return `${url}/address/${getAddress(address)}`;
}

export function prefixWithPragma(code: string) {
  return `// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

${code}`;
}

export function prefixWithGeneratedWarning(code: string) {
  return `// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n${code}`;
}

export function wrapIntoSolidityLibrary(code: string[], libraryName: string) {
  return `library ${libraryName} {
    ${code.join('\n')}
  }`;
}

export function addressInfoToSolidityLibraryConstant(
  chainId: number,
  key: string,
  entry: AddressInfo,
) {
  if (typeof entry === 'object') {
    if (entry.type === 'uint256' || entry.type === 'uint8') {
      return `${entry.type} internal constant ${key} = ${entry.value};\n`;
    }
    if (!entry.value) console.log('entry', entry);
    const blockExplorerLinkComment = getExplorerLink(entry.chainId || chainId, entry.value);
    if (entry.type === 'address')
      return `// ${blockExplorerLinkComment}\naddress internal constant ${key} = ${getAddress(
        entry.value,
      )};\n`;
    return `// ${blockExplorerLinkComment}\n${entry.type} internal constant ${key} = ${
      entry.type
    }(${getAddress(entry.value)});\n`;
  }
  const blockExplorerLinkComment = getExplorerLink(chainId, entry);
  return `// ${blockExplorerLinkComment}\naddress internal constant ${key} = ${getAddress(
    entry,
  )};\n`;
}

function keyToVar(key: string) {
  return key
    .replace(/^(\d)/, '_$1')
    .replace(/\+/g, 'Plus')
    .replace(/ü/g, 'ue')
    .replace(/ä/g, 'ae')
    .replace(/ö/g, 'oe')
    .replace(/ß/g, 'ss')
    .replace(/^\s\s*/, '')
    .replace(/\./g, '')
    .replace(/[^\w\ ]/gi, ' ') //  replaces all non-alphanumeric with empty string
    .replace(/-{2,}/g, ' ') //  remove duplicate spaces
    .replace(/\s\s*$/, '') //  trim both sides of string
    .replace(/ +/gi, '_'); //  Convert spaces to dashes,
}

export function generateSolidityConstants({
  chainId,
  addresses,
}: {
  chainId: number;
  addresses: Addresses;
}) {
  return Object.keys(addresses)
    .filter((key) =>
      typeof addresses[key] !== 'object'
        ? addresses[key] !== zeroAddress
        : addresses[key].value !== zeroAddress,
    )
    .map((key) => addressInfoToSolidityLibraryConstant(chainId, keyToVar(key), addresses[key]));
}

export function addressToJsConstant(chainId: number, key: string, entry: AddressInfo) {
  if (typeof entry === 'object') {
    if (entry.type === 'uint256') {
      return `export const ${key} = ${entry.value};\n`;
    }
    const blockExplorerLinkComment = getExplorerLink(entry.chainId || chainId, entry.value);
    return `// ${entry.type} ${blockExplorerLinkComment}\n export const ${keyToVar(
      key,
    )} = '${getAddress(entry.value)}';\n`;
  }

  const blockExplorerLinkComment = getExplorerLink(chainId, entry);
  return `// ${blockExplorerLinkComment}\nexport const ${keyToVar(key)} = '${getAddress(entry)}';\n`;
}

export function generateJsConstants({chainId, addresses}: {chainId: number; addresses: Addresses}) {
  return Object.keys(addresses)
    .filter((key) =>
      typeof addresses[key] !== 'object'
        ? addresses[key] !== zeroAddress
        : addresses[key].value !== zeroAddress,
    )
    .map((key) => addressToJsConstant(chainId, key, addresses[key]));
}

export function generateJsObject(object: any) {
  return JSON.stringify(
    object,
    function (key, value) {
      if (!key) return value;
      return typeof value === 'object' ? value.value : value;
    },
    2,
  );
}

export const bytes32toAddress = (bytes32: Hex) => {
  return getAddress(`0x${bytes32.slice(26)}`);
};

export const getImplementationStorageSlot = async (client: Client, address: Hex) => {
  return (await getStorageAt(client, {
    address,
    slot: '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc',
  })) as Hex;
};

export function addressOrZero(address?: Hex): Hex {
  if (address) return address;
  return zeroAddress;
}

export function removeNetworkAbbreviation(symbol: string): string {
  return symbol.replace('BasSep', '').replace('Eth', '');
}

export async function getTokenSymbol(client: Client, token: Hex): Promise<string> {
  const tokenContract = getContract({
    address: token,
    abi: IERC20Detailed_ABI,
    client,
  });
  return await tokenContract.read.symbol();
}

export function extractTypes(addresses: Addresses): string[] {
  const types = new Set<string>();
  for (const key in addresses) {
    const entry = addresses[key];
    if (entry && typeof entry === 'object' && 'type' in entry && typeof entry.type === 'string') {
      types.add(entry.type);
    }
  }
  return Array.from(types);
}
