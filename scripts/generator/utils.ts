import {Client, Hex, getAddress, zeroAddress} from 'viem';
import {AddressInfo, Addresses} from '../configs/types';
import {getStorageAt} from 'viem/actions';
import {ChainList} from '@bgd-labs/rpc-env';

function getExplorerLink(chainId: number, address: Hex) {
  const chain = ChainList[chainId];
  let url = chain.blockExplorers?.default.url;
  if (url && url.endsWith('/')) {
    url = url.slice(0, -1); // sanitize explorer url
  }
  return `${url}/address/${getAddress(address)}`;
}

export function prefixWithPragma(code: string) {
  return `// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

${code}`;
}

export function prefixWithGeneratedWarning(code: string) {
  return `// AUTOGENERATED - MANUALLY CHANGES WILL BE REVERTED BY THE GENERATOR\n${code}`;
}

export function wrapIntoSolidityLibrary(code: string[], libraryName: string) {
  return `library ${libraryName} {
    ${code.join('\n')}
  }`;
}

export function addressInfoToSolidityLibraryConstant(
  chainId: number,
  key: string,
  entry: AddressInfo,
) {
  if (typeof entry === 'object') {
    if (entry.type === 'uint256' || entry.type === 'uint8') {
      return `${entry.type} internal constant ${key} = ${entry.value};\n`;
    }
    const blockExplorerLinkComment = getExplorerLink(entry.chainId || chainId, entry.value);
    if (entry.type === 'address')
      return `// ${blockExplorerLinkComment}\naddress internal constant ${key} = ${getAddress(
        entry.value,
      )};\n`;
    return `// ${blockExplorerLinkComment}\n${entry.type} internal constant ${key} = ${
      entry.type
    }(${getAddress(entry.value)});\n`;
  }
  const blockExplorerLinkComment = getExplorerLink(chainId, entry);
  return `// ${blockExplorerLinkComment}\naddress internal constant ${key} = ${getAddress(
    entry,
  )};\n`;
}

export function generateSolidityConstants({
  chainId,
  addresses,
}: {
  chainId: number;
  addresses: Addresses;
}) {
  return Object.keys(addresses)
    .filter((key) =>
      typeof addresses[key] !== 'object'
        ? addresses[key] !== zeroAddress
        : addresses[key].value !== zeroAddress,
    )
    .map((key) => addressInfoToSolidityLibraryConstant(chainId, key, addresses[key]));
}

export function addressToJsConstant(chainId: number, key: string, entry: AddressInfo) {
  if (typeof entry === 'object') {
    if (entry.type === 'uint256') {
      return `export const ${key} = ${entry.value};\n`;
    }
    const blockExplorerLinkComment = getExplorerLink(entry.chainId || chainId, entry.value);
    return `// ${entry.type} ${blockExplorerLinkComment}\n export const ${key} = '${getAddress(
      entry.value,
    )}';\n`;
  }

  const blockExplorerLinkComment = getExplorerLink(chainId, entry);
  return `// ${blockExplorerLinkComment}\nexport const ${key} = '${getAddress(entry)}';\n`;
}

export function generateJsConstants({chainId, addresses}: {chainId: number; addresses: Addresses}) {
  return Object.keys(addresses)
    .filter((key) =>
      typeof addresses[key] !== 'object'
        ? addresses[key] !== zeroAddress
        : addresses[key].value !== zeroAddress,
    )
    .map((key) => addressToJsConstant(chainId, key, addresses[key]));
}

export function generateJsObject(object: any) {
  return JSON.stringify(
    object,
    function (key, value) {
      if (!key) return value;
      return typeof value === 'object' ? value.value : value;
    },
    2,
  );
}

export const bytes32toAddress = (bytes32: Hex) => {
  return getAddress(`0x${bytes32.slice(26)}`);
};

export const getImplementationStorageSlot = async (client: Client, address: Hex) => {
  return (await getStorageAt(client, {
    address,
    slot: '0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc',
  })) as Hex;
};

export function addressOrZero(address?: Hex): Hex {
  if (address) return address;
  return zeroAddress;
}

export function bitMapToIndexes(bitmap: bigint) {
  const reserveIndexes: number[] = [];
  for (let i = 0; bitmap != 0n; i++) {
    if (bitmap & 0x1n) reserveIndexes.push(i);
    bitmap = bitmap >> 1n;
  }
  return reserveIndexes;
}
