import fs from 'fs';

import {Pool, pools} from './config';
import {fetchPoolV2Addresses, writeV2Templates} from './generator_v2';
import {fetchPoolV3Addresses, writeV3Templates} from './generator_v3';

async function generateV2Pools(pools: Pool[]) {
  const generatedPools = await Promise.allSettled(
    pools.map(async (pool) => {
      const addresses = await fetchPoolV2Addresses(pool);
      await writeV2Templates(addresses);
      return addresses;
    })
  );

  const failedPools = generatedPools.filter((promise) => promise.status === 'rejected');

  if (failedPools.length > 0) {
    failedPools.forEach((failedPool: any) => {
      const error = JSON.parse(failedPool.reason.message);
      console.log(`
        Could not generate pool for:
        - pool: ${error.pool.name}
        - pool version: ${error.pool.version}
        - network rpc: ${error.pool.rpc}
        - trace: ${error.stack}
      `);
    });

    throw new Error('Some pools where not properly generated');
  }

  return generatedPools.map((m: any) => m.value);
}

async function generateV3Pools(pools: Pool[]) {
  const generatedPools = await Promise.allSettled(
    pools.map(async (pool) => {
      const addresses = await fetchPoolV3Addresses(pool);
      await writeV3Templates(addresses);
      return addresses;
    })
  );

  const failedPools = generatedPools.filter((promise) => promise.status === 'rejected');

  if (failedPools.length > 0) {
    failedPools.forEach((failedPool: any) => {
      const error = JSON.parse(failedPool.reason.message);
      console.log(`
        Could not generate pool for:
        - pool: ${error.pool.name}
        - pool version: ${error.pool.version}
        - network rpc: ${error.pool.rpc}
        - trace: ${error.stack}
      `);
    });

    throw new Error('Some pools where not properly generated');
  }

  return generatedPools.map((m: any) => m.value);
}

async function generatePools() {
  // Create the test for the specified pool
  const aaveAddressBookSolidityTemplate = `// SPDX-License-Identifier: MIT
pragma solidity >=0.6.0;

${pools.reduce((acc, pool) => {
  acc += `import {${pool.name}} from "./${pool.name}.sol";\r\n`;
  return acc;
}, '')}

import {AaveGovernanceV2, IGovernanceStrategy} from './AaveGovernanceV2.sol';
import {IAaveEcosystemReserveController, AaveMisc} from './AaveMisc.sol';
\r\n`;
  fs.writeFileSync(`./src/AaveAddressBook.sol`, aaveAddressBookSolidityTemplate);

  const aaveAddressBookJsTemplate = `export * as AaveGovernanceV2 from "./AaveGovernanceV2";
  export * as AaveSafetyModule from "./AaveSafetyModule";
  // autogenerated entrypoints
  ${pools.reduce((acc, pool) => {
    acc += `export * as ${pool.name} from "./${pool.name}";\r\n`;
    return acc;
  }, '')}`;
  fs.writeFileSync(`./src/ts/AaveAddressBook.ts`, aaveAddressBookJsTemplate);
  await generateV2Pools(pools.filter((pool) => pool.version === 2));
  await generateV3Pools(pools.filter((pool) => pool.version === 3));
}

generatePools()
  .then(() => {
    console.log('pools successfully generated');
    process.exit(0);
  })
  .catch((error) => {
    console.log(error);
    process.exit(1);
  });
